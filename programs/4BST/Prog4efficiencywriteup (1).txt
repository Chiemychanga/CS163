Larry Chiem 
CS163 Program 4 Efficiency Review Write-up
Our assigned application wanted us to create a table for our study guide, organizing data by keywords alphabetically. By using a recursive Binary Search Tree for the assigned application, it worked better than an array of Linear Linked List or hash table chaining because of it’s efficiency to insert sorted (unlike the last program which was not sorted), remove and retrieve (all at best case O(log(n)) and worst case at O(n)). This allowed for our deletion and searches to be done way quicker as everything was sorted, and the comparisons were possible to cut down our run time efficiency. 
        An AVL tree instead of a BST would work better than a BST because worst case scenario for a BST, which is a linear case causing O(n) for worst case, won’t occur because AVL’s auto balance their trees so worst case is O(log n). The BST itself can mess up by inserting with the worst-case data into a linear linked list. Luckily, in my external study.txt file, I did not write the data in alphabetical order, otherwise that would have instantly created the worst case scenario. Luckily, I’m also dealing only with about 4 data pieces, so the amount of problems is relatively small and you don’t have much to worry about. If we were running with like millions and more data problems, then efficiency would matter and an AVL tree would have been useful. WIth the AVL tree, all of the leaves are at the same height. 
What was efficient about my design and use of a binary search tree instead of our array of linear linked list (like in our last program) is that, if the tree is reasonably balanced, the insert, lookup, and delete operations can all be implemented to run in O(log N) time, where N is the number of stored items. Also, everything is sorted order by keyword. Logarithmic time is generally much faster than linear time.
It wouldn’t be efficient with O(n) if all of the inserted items was going to the right. Then it’d basically just be a Linear linked list. At that point you’d just use a LLL. So I can’t really guarantee the order of the data based off the manual client entries, but I can guarantee that the order of the data read in from the external file is not in order alphabetically, preventing linear and worst case inserts. 
Recursive BST versus an iterative search tree usually takes more space than iterative, called “call-stack”, and runs slower than iterative.  Also, in my headers above every function, I could have been more specific and listed out details so that anyone else looking at my code could easily understand. I really want to become good at documenting, it would become useful in teamwork coding. By looking at how code tutorials like codecademy or even Karla’s lab manuals, it is very detailed and allows me to understand what the code does. Lucky thing we have her style requirements. 
If I would have done it differently, I would have just created an AVL tree so that it balances out my tree and prevents the worst case scenario of a linear tree. I also had some memory leaks that I never knew how to run through valgrind until a couple of days before the due date. I should have brushed up or learned how to use that. However, although an AVL tree balances the leafs to be all at the same height, I can’t say that it’d be more efficient than a BST since it is a little more complex for somewhat of a simple program.