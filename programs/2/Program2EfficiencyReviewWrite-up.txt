Larry Chiem 
CS163 Program 2 Efficiency Review Write-up


        The stack ADT (FILO - first in last out) using a linear linked list of arrays to represent the contents of the POD or container performed well. By performing the pop function, it represented taking out the first (top) package from the back of the POD or container. By the time I have popped through to the last package, that would be the last package inside the POD which is located all the way in the back. When I pushed onto the stack, it represented adding a new package into the back of the POD. 
        The queue ADT using a circular linked list represented the list of recipients for delivery. It basically held the same stuff as the stack ADT but it didn’t have a list of arrays. When I enqueued to the rear of the list and dequeue from the front, it represented the FIFO concept, which can’t work the same as the stack. So the queue would be an inconvenient ADT for this program.
        A doubly linked list would have worked better than the circular linked list for the queue ADT because then we could remove from the either the rear or from the front, which more likely represents dequeueing after every package being delivered. As of now, my queue is backwards, so if I were to deliver what's in the back of the pod, then my dequeue would make sense. But it can’t. 
        My display for the stack was efficient in that I didn’t display from starting from the first orders of the pod/stack, I displayed from the end of the pod/stack, which is the first packages pushed. This way, when everything is displayed, I should see the first orders and as I pop, I will eventually get to the back of the pod/stack. 
        I did not hold a position number for each of the elements in the array, which created problems where it didn’t save top_index. So because my size of arrays is 5, if I had an array that only had 3 of the 5 elements filled, it wouldn’t have saved my top index at 3 because it never saved a position number. 
If I had 5 packages for one recipient, but there are other packages in between each element for that recipient, I’d have to revisit that recipient 5 different times. 
        If I had more time to solve the problem, I would only have used a linked list of arrays. I don’t see the point of the circular linked list (FIFO). That way, every node was for one recipient, the array for the number of packages, and it would pop off every package until it was empty, then dequeue that recipient off the list when all of their packages are delivered. Normally, in a circular linked list, we enqueue to the rear and dequeue from the front, this is the complete opposite of the data structure we want for the pod container. Which is why a linked list queue of arrays would allow us start filling up the empty pod at the front, and eventually when the pod is full, the last thing we put in the pod will be the first thing out. Remove is done at the head too. When we display everything, normally we display from head and traverse till the end (this would show last the last item in the pod, requiring the viewer to scroll up to see what should be the first thing they see when they open the door). We don’t want that. Instead, the displayall has to look at the end of the list, and display everything it backwards, so the first thing we see is what is at head.